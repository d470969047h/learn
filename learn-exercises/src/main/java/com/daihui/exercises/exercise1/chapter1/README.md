# 1.谈谈你对volatile的理解

## 1.volatile是Java虚拟机提供的轻量级的同步机制

- 保证可见性

- 不保证原子性

- 禁止指令重排


## 2.JMM你谈谈

JMM（Java内存模型，简称JMM）本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，
通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

JMM关于同步的规定：

1.线程解锁前，必须把共享变量的值刷新回主内存。

2.线程加锁前，必须读取主内存的最新值到自己的工作内存。

3.加锁解锁是同一把锁。

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），
工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储到主内存，主内存是共享内存区域，
所有线程都可以访问，但线程对变量的操作（读取、复制等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，
然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，
因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：

![1png](https://raw.githubusercontent.com/d470969047h/learn/master/learn-exercises/src/main/resources/exercise1/chapter1/1.png)

- 可见性

  通过前面对JMM的介绍，我们知道  
  各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回主内存中的。  
  这就可能存在一个线程A修改了共享变量X的值但还未写回主内存时，另一个线程B又对准内存中同一个共享变量X进行操作，但此时A线程工作内存中共享变量X对线程B来说并不是可见，这种工作内存与主内存同步存在延迟现象就造成了可见性问题。

- 原子性

- 有序性

  计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分一下3种：  
  源代码->编译器优化的重排->指令并行的重排->内存系统的重排->最终执行的指令  
  单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。  
  处理器在进行重排序时必须考虑指令之间的数据依赖性。  
  多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。
  
  禁止指令重排小总结：  
  volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。  
  先了解一个概念，内存屏障又称内存栅栏，是一个CPU指令，它的作用有两个：  
  一是保证特定操作的执行顺序  
  二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）  
  由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重新排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。

### 线程安全获得保证

1.工作内存和主内存同步延迟现象导致的可见性问题  

可以使用synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其他线程可见。

2.对于指令重排导致的可见性问题和有序性问题  

可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化。


## 3.你在哪些地方用过volatile？

3.1单例模式DCL代码

3.2单例模式volatile分析

DCL（双端检锁）机制不一定线程安全，原因是有指令重排序的存在，加入volatile可以禁止指令重排。

原因在于某一个线程执行到第一个检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。

指令重排只会保证串行语义的执行一致性（单线程），但并不会关心多线程间的语义一致性。

所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。
