<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p><strong>Java虚拟机内部构成浅析</strong></p><p>2009-06-18 13:51 佚名 JavaEye 字号：<a href="javascript:setfont(12);" target="_self">T</a> | <a href="javascript:setfont(16);" target="_self">T</a></p><p>Java虚拟机由五部分组成：指令集、寄存器、栈、无用单元回收堆、方法区域，本文将带您深入Java虚拟机的内部体系。</p><p>AD：</p><p>Java虚拟机是一个想象中的机器，正如其名是虚拟的。在实际计算机上市通过软件模拟实现的。它有虚拟的硬件，如处理器、堆栈、寄存器等，还有相应的指令系统。它屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码即字节码，这样就可以在多个平台上不加修改的运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这正是Java语言具有与平台无关性的原因。</p><p>Java虚拟机由五部分组成：指令集、寄存器、栈、无用单元回收堆（garbage-collected-heap)、方法区域。它们构成了Java虚拟机的逻辑成份，不依赖任何实现技术或组织方式，但他们的功能必须在真实机器上以某种方式实现。Java虚拟机支持大约248个字节码。每个字节码执行一种基本的CPU运算，例如，把一个整数加到寄存器，子程序转移等。Java指令集相当于Java程序的汇编语言。其中的指令包含一个单字节的操作符，用于指定要执行的操作，还有0个或多个操作数，提供操作所需的参数或数据。许多指令没有操作数，仅有一个单字节的操作符构成。虚拟机的內层循环的执行过程如下：</p><p>do{取一个操作符字节：根据操作符的值执行一个动作；}while(程序未结束）</p><p>由于指令系统的简单性，使得虚拟机的执行过程十分简单，从而有利于提高执行效率。指令中操作数的数量和大小是由操作符决定的。如果操作数比一个字节大那么它存储的顺序是高字节优先。例如，一个16位的参数存放时占用两个字节，其值为第一个字节×256+第二个字节。字节码指令流一般只是字节对齐的。指令tableswitch和lookup是例外，这两条指令内部要求强制的4字节边界对齐。</p><p> </p><p>Java虚拟机的寄存器用于保存机器的运行状态，与微处理器中的某些专用寄存器类似。Java虚拟机的寄存器有4种：pc：Java程序计数器，optop：指向操作数栈顶端的指针，frame：指向当前执行环境的指针，vars：指向当前执行方法的局部变量区第一个变量的指针。Java虚拟机是栈式的，他不定义或使用寄存器来传递或接受参数，其目的是为了保证指令集的简洁性和实现时的高效性特别是对于寄存器数目不多的处理器。所有寄存器 都是32位的。</p><p>Java虚拟机的栈有三个区域：局部变量区、运行环境区、操作数区。局部变量区每个Java方法使用一个固定大小的局部变量集。它们按照与ars寄存器的字偏移量来寻址。局部变量都是32位的。长整数和双精度浮点数占据了2个局部变量的空间，却按照第一个局部变量的索引来寻址。虚拟机规范并不要求在局部变量中的64 为的值是64位对其的虚拟机提供了把局部变量中的值装载到操作数栈的指令，也提供了把操作数栈中的值写入局部变量的指令。</p><p>在运行环境中包含的信息用于动态链接，正常的方法返回以及异常传播。运行环境包括对指向当前类和当前方法的解释器符号表的指针，用于支持方法代码的动态链接。方法的class文件代码在引用要调用的方法和要访问的变量时使用符号。动态链接把符号形式的方法调用翻译成实际方法调用，装载必要的类以解释还没有定义的符号，并把变量访问翻译成与这些变量运行时的存贮结构相应的偏移地址。动态链接方法和变量使的方法中使用的其它类的变化不会影响到本程序的代码。如果当前方法正常地结束了，在执行了一条具有正确类型的返回指令时，调用的方法会得到一个返回值。执行环境在正常返回的情况下用于恢复调用者的寄存器，并把调用者的寄存器计算器增加一个恰当的值，一跳过已执行过的方法。调用指令然后再调用者的执行环境中继续执行下去。异常情况下在Java中被称作error（错误）或exception（异常），是throwable类的子类。在程序中出错的原因是动态链接出错如无法找到所需class文件，运行时出错如一个空指针的引用。程序使用了throw语句。</p><p>当异常发生时，Java虚拟机采取如下措施：检查与当前方法相关的catch子句表，每个catch子句包含其有效指令范围，能够处理异常类型以及处理异常代码块地址。与异常相匹配的catch子句应该符合一下条件：造成异常的指令在指令范围内，发生异常类型是其能够处理的异常类型的子类型。如果找到了匹配的catch子句，那么系统转到异常处理模块执行；否则重复寻找直到找到为止。如果找不到则得到一个“未截获异常”的结果并返回到当前方法的调用者好像异常刚刚在其调用者中发生一样。如果调用者仍然没有找到相应的异常处理，那么系统将调用一个缺省的异常处理模块。</p><p> </p><p>机器指令只从操作数栈中取操作数，对他们进行操作，并把结果返回到栈中。栈用于给方法传递参数并从方法接受结果，也用于支持操作数的参数并保存操作结果。Java的堆是一个运行时数据区，类的实例从中分配空间。Java语言有无用单元回收功能：不给程序员显式释放对象的能力。不规定具体使用的无用单元收集算法。可以根据系统需求使用各种各样的算法。</p><p>方法区与传统语言中的编译后代码或是unix进程中的正文段相似。保存方法代码（编译后的Java代码）和符号表。在当前的Java实现中，方法代码不包括在无用回收集堆中但计划在将来的版本实现。</p><h1><a href="file:///E:\ccit0519\article\details\11241403">深入理解Java内存模型之系列篇</a></h1><p>分类： <a href="file:///E:\ccit0519\article\category\1199451">Java基础知识</a> 2013-09-06 16:44 1580人阅读 <a href="file:///E:\JAVA\%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%B3%BB%E5%88%97%E7%AF%87%20-%20ccit0519%E7%9A%84%E4%B8%93%E6%A0%8F%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET.htm#comments">评论</a>(1) <a href="javascript:void(0);">收藏</a> <a href="file:///E:\JAVA\%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%B3%BB%E5%88%97%E7%AF%87%20-%20ccit0519%E7%9A%84%E4%B8%93%E6%A0%8F%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET.htm#report">举报</a></p><h1><a href="http://www.infoq.com/cn/articles/java-memory-model-1;jsessionid=BD8B8C0EEF03812D37F0CA399D59D690" target="_blank"><br />深入理解Java内存模型（一）——基础</a></h1><h2><a id="t5"></a>并发编程模型的分类</h2><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><h2><a id="t6"></a>Java内存模型的抽象</h2><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p><p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p><ol><li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li><li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li></ol><p>下面通过示意图来说明这两个步骤：</p><p>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。</p><p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p><h2><a id="t7"></a>重排序</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h2><a id="t8"></a>处理器重排序与内存屏障指令</h2><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：</p><table><tr><td><p><strong>Processor A</strong></p></td><td><p><strong>Processor B</strong></p></td></tr><tr><td><p>a = 1; //A1<br />x = b; //A2</p></td><td><p>b = 2; //B1<br />y = a; //B2</p></td></tr><tr><td colspan="2"><p>初始状态：a = b = 0<br />处理器允许执行后得到结果：x = y = 0</p></td></tr></table><p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到x = y = 0的结果。具体的原因如下图所示：</p><p>这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。</p><p>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）。</p><p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操做重排序。</p><p>下面是常见处理器允许的重排序类型的列表：</p><table><tr><td></td><td><p>Load-Load</p></td><td><p>Load-Store</p></td><td><p>Store-Store</p></td><td><p>Store-Load</p></td><td><p>数据依赖</p></td></tr><tr><td><p>sparc-TSO</p></td><td><p>N</p></td><td><p>N</p></td><td><p>N</p></td><td><p>Y</p></td><td><p>N</p></td></tr><tr><td><p>x86</p></td><td><p>N</p></td><td><p>N</p></td><td><p>N</p></td><td><p>Y</p></td><td><p>N</p></td></tr><tr><td><p>ia64</p></td><td><p>Y</p></td><td><p>Y</p></td><td><p>Y</p></td><td><p>Y</p></td><td><p>N</p></td></tr><tr><td><p>PowerPC</p></td><td><p>Y</p></td><td><p>Y</p></td><td><p>Y</p></td><td><p>Y</p></td><td><p>N</p></td></tr></table><p>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。</p><p>从上表我们可以看出：常见的处理器都允许Store-Load重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO和x86拥有相对较强的处理器内存模型，它们仅允许对写-读操作做重排序（因为它们都使用了写缓冲区）。</p><p>※注1：sparc-TSO是指以TSO(Total Store Order)内存模型运行时，sparc处理器的特性。</p><p>※注2：上表中的x86包括x64及AMD64。</p><p>※注3：由于ARM处理器的内存模型与PowerPC处理器的内存模型非常类似，本文将忽略它。</p><p>※注4：数据依赖性后文会专门说明。</p><p>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p><table><tr><td><p>屏障类型</p></td><td><p>指令示例</p></td><td><p>说明</p></td></tr><tr><td><p>LoadLoad Barriers</p></td><td><p>Load1; LoadLoad; Load2</p></td><td><p>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</p></td></tr><tr><td><p>StoreStore Barriers</p></td><td><p>Store1; StoreStore; Store2</p></td><td><p>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</p></td></tr><tr><td><p>LoadStore Barriers</p></td><td><p>Load1; LoadStore; Store2</p></td><td><p>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</p></td></tr><tr><td><p>StoreLoad Barriers</p></td><td><p>Store1; StoreLoad; Load2</p></td><td><p>确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p></td></tr></table><p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><h2><a id="t9"></a>happens-before</h2><p>从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133提出了happens-before的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的happens-before规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</li><li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li></ul><p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before的定义很微妙，后文会具体说明happens-before为什么要这么定义。</p><p>happens-before与JMM的关系如下图所示：</p><p>如上图所示，一个happens-before规则通常对应于多个编译器重排序规则和处理器重排序规则。对于java程序员来说，happens-before规则简单易懂，它避免程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p><a id="t10"></a><h1><a href="http://www.infoq.com/cn/articles/java-memory-model-2&quot; \t &quot;_blank">深入理解Java内存模型（二）——重排序</a></h1><h2><a id="t11"></a>数据依赖性</h2><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p><table><tr><td><p>名称</p></td><td><p>代码示例</p></td><td><p>说明</p></td></tr><tr><td><p>写后读</p></td><td><p>a = 1;b = a;</p></td><td><p>写一个变量之后，再读这个位置。</p></td></tr><tr><td><p>写后写</p></td><td><p>a = 1;a = 2;</p></td><td><p>写一个变量之后，再写这个变量。</p></td></tr><tr><td><p>读后写</p></td><td><p>a = b;b = 1;</p></td><td><p>读一个变量之后，再写这个变量。</p></td></tr></table><p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p><p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p><h2><a id="t12"></a>as-if-serial语义</h2><p>as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p><p>double pi  = 3.14;    //A</p><p>double r   = 1.0;     //B</p><p>double area = pi * r * r; //C</p><p>上面三个操作的数据依赖关系如下图所示：</p><p>如上图所示，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。下图是该程序的两种执行顺序：</p><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><h2><a id="t13"></a>程序顺序规则</h2><p>根据happens- before的程序顺序规则，上面计算圆的面积的示例代码存在三个happens- before关系：</p><ol><li>A happens- before B；</li><li>B happens- before C；</li><li>A happens- before C；</li></ol><p>这里的第3个happens- before关系，是根据happens- before的传递性推导出来的。</p><p>这里A happens- before B，但实际执行时B却可以排在A之前执行（看上面的重排序后的执行顺序）。在第一章提到过，如果A happens- before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B按happens- before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法（not illegal），JMM允许这种重排序。</p><p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从happens- before的定义我们可以看出，JMM同样遵从这一目标。</p><h2><a id="t14"></a>重排序对多线程的影响</h2><p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：</p><p>class ReorderExample {</p><p>int a = 0;</p><p>boolean flag = false;</p><p>public void writer() {</p><p>    a = 1;                   //1</p><p>    flag = true;             //2</p><p>}</p><p>Public void reader() {</p><p>    if (flag) {                //3</p><p>        int i =  a * a;        //4</p><p>        ……</p><p>    }</p><p>}</p><p>}</p><p>flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入？</p><p>答案是：不一定能看到。</p><p>由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作1和操作2重排序时，可能会产生什么效果？请看下面的程序执行时序图：</p><p>如上图所示，操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还根本没有被线程A写入，在这里多线程程序的语义被重排序破坏了！</p><p>※注：本文统一用红色的虚箭线表示错误的读操作，用绿色的虚箭线表示正确的读操作。</p><p>下面再让我们看看，当操作3和操作4重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作3和操作4重排序后，程序的执行时序图：</p><p>在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作3的条件判断为真时，就把该计算结果写入变量i中。</p><p>从图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！</p><p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><a id="t15"></a><h1><a href="http://www.infoq.com/cn/articles/java-memory-model-3&quot; \t &quot;_blank">深入理解Java内存模型（三）——顺序一致性</a></h1><h2><a id="t16"></a>数据竞争与顺序一致性保证</h2><p>当程序未正确同步时，就会存在数据竞争。java内存模型规范对数据竞争的定义如下：</p><ul><li>在一个线程中写一个变量，</li><li>在另一个线程读同一个变量，</li><li>而且写和读没有通过同步来排序。</li></ul><p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果（前一章的示例正是如此）。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p><p>JMM对正确同步的多线程程序的内存一致性做了如下保证：</p><ul><li>如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）--即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile和final）的正确使用。</li></ul><h2><a id="t17"></a>顺序一致性内存模型</h2><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序来执行。</li><li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ul><p>顺序一致性内存模型为程序员提供的视图如下：</p><p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读/写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化。</p><p>为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。</p><p>假设有两个线程A和B并发执行。其中A线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。</p><p>假设这两个线程使用监视器来正确同步：A线程的三个操作执行后释放监视器，随后B线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：</p><p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p><p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程A和B看到的执行顺序都是：B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p><p>但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p><h2><a id="t18"></a>同步程序的顺序一致性效果</h2><p>下面我们对前面的示例程序ReorderExample用监视器来同步，看看正确同步的程序如何具有顺序一致性。</p><p>请看下面的示例代码：</p><p>class SynchronizedExample {</p><p>int a = 0;</p><p>boolean flag = false;</p><p>public synchronized void writer() {</p><p>    a = 1;</p><p>    flag = true;</p><p>}</p><p>public synchronized void reader() {</p><p>    if (flag) {</p><p>        int i = a;</p><p>        ……</p><p>    }</p><p>}</p><p>}</p><p>上面示例代码中，假设A线程执行writer()方法后，B线程执行reader()方法。这是一个正确同步的多线程程序。根据JMM规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：</p><p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程A在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p><p>从这里我们可以看到JMM在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p><h2><a id="t19"></a>未同步程序的执行特性</h2><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM保证线程读操作读取到的值不会无中生有（out of thin air）的冒出来。为了实现最小安全性，JVM在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在以清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。</p><p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未同步程序在顺序一致性模型中执行时，整体上是无序的，其执行结果无法预知。保证未同步程序在两个模型中的执行结果一致毫无意义。</p><p>和顺序一致性模型一样，未同步程序在JMM中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：</p><ol><li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。</li><li>JMM不保证对64位的long型和double型变量的读/写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li></ol><p>第3个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和I/O设备执行内存的读/写。下面让我们通过一个示意图来说明总线的工作机制：</p><p>如上图所示，假设处理器A，B和C同时向总线发起总线事务，这时总线仲裁（bus arbitration）会对竞争作出裁决，这里我们假设总线在仲裁后判定处理器A在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器A继续它的总线事务，而其它两个处理器则要等待处理器A的总线事务完成后才能开始再次执行内存访问。假设在处理器A执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器D向总线发起了总线事务，此时处理器D的这个请求会被总线禁止。</p><p>总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p><p>在一些32位的处理器上，如果要求对64位数据的读/写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的读/写具有原子性。当JVM在这种处理器上运行时，会把一个64位long/ double型变量的读/写操作拆分为两个32位的读/写操作来执行。这两个32位的读/写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的读/写将不具有原子性。</p><p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：</p><p>如上图所示，假设处理器A写一个long型变量，同时处理器B要读这个long型变量。处理器A中64位的写操作被拆分为两个32位的写操作，且这两个32位的写操作被分配到不同的写事务中执行。同时处理器B中64位的读操作被拆分为两个32位的读操作，且这两个32位的读操作被分配到同一个的读事务中执行。当处理器A和B按上图的时序来执行时，处理器B将看到仅仅被处理器A“写了一半“的无效值。</p><a id="t20"></a><h1><a href="http://www.infoq.com/cn/articles/java-memory-model-4&quot; \t &quot;_blank">深入理解Java内存模型（四）——volatile</a></h1><h2><a id="t21"></a>volatile的特性</h2><p>当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。下面我们通过具体的示例来说明，请看下面的示例代码：</p><p>class VolatileFeaturesExample {</p><p>    volatile long vl = 0L;  //使用volatile声明64位的long型变量</p><p>    public void set(long l) {</p><p>        vl = l;   //单个volatile变量的写</p><p>    }</p><p>    public void getAndIncrement () {</p><p>        vl++;    //复合（多个）volatile变量的读/写</p><p>    }</p><p>    public long get() {</p><p>        return vl;   //单个volatile变量的读</p><p>    }</p><p>}</p><p>假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价：</p><p>class VolatileFeaturesExample {</p><p>    long vl = 0L;               // 64位的long型普通变量</p><p>    public synchronized void set(long l) {     //对单个的普通 变量的写用同一个监视器同步</p><p>        vl = l;</p><p>    }</p><p>    public void getAndIncrement () { //普通方法调用</p><p>        long temp = get();           //调用已同步的读方法</p><p>        temp += 1L;                  //普通写操作</p><p>        set(temp);                   //调用已同步的写方法</p><p>    }</p><p>    public synchronized long get() { </p><p>    //对单个的普通变量的读用同一个监视器同步</p><p>        return vl;</p><p>    }</p><p>}</p><p>如上面示例程序所示，对一个volatile变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个监视器锁来同步，它们之间的执行效果相同。</p><p>监视器锁的happens-before规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p><p>监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。</p><p>简而言之，volatile变量自身具有下列特性：</p><ul><li>可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li><li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li></ul><h2><a id="t22"></a>volatile写-读建立的happens before关系</h2><p>上面讲的是volatile变量自身的特性，对程序员来说，volatile对线程的内存可见性的影响比volatile自身的特性更为重要，也更需要我们去关注。</p><p>从JSR-133开始，volatile变量的写-读可以实现线程之间的通信。</p><p>从内存语义的角度来说，volatile与监视器锁有相同的效果：volatile写和监视器的释放有相同的内存语义；volatile读与监视器的获取有相同的内存语义。</p><p>请看下面使用volatile变量的示例代码：</p><p>class VolatileExample {</p><p>    int a = 0;</p><p>    volatile boolean flag = false;</p><p>    public void writer() {</p><p>        a = 1;                   //1</p><p>        flag = true;               //2</p><p>    }</p><p>    public void reader() {</p><p>        if (flag) {                //3</p><p>            int i =  a;           //4</p><p>            ……</p><p>        }</p><p>    }</p><p>}</p><p>假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：</p><ol><li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li><li>根据volatile规则，2 happens before 3。</li><li>根据happens before 的传递性规则，1 happens before 4。</li></ol><p>上述happens before 关系的图形化表现形式如下：</p><p>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p><p>这里A线程写一个volatile变量后，B线程读同一个volatile变量。A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。</p><h2><a id="t23"></a>volatile写-读的内存语义</h2><p>volatile写的内存语义如下：</p><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</li></ul><p>以上面示例程序VolatileExample为例，假设线程A首先执行writer()方法，随后线程B执行reader()方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行volatile写后，共享变量的状态示意图：</p><p>如上图所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。</p><p>volatile读的内存语义如下：</p><ul><li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li></ul><p>下面是线程B读同一个volatile变量后，共享变量的状态示意图：</p><p>如上图所示，在读flag变量后，本地内存B已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值也变成一致的了。</p><p>如果我们把volatile写和volatile读这两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p><p>下面对volatile写和volatile读的内存语义做个总结：</p><ul><li>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所在修改的）消息。</li><li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。</li><li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><h2><a id="t24"></a>volatile内存语义的实现</h2><p>下面，让我们来看看JMM如何实现volatile写/读的内存语义。</p><p>前文我们提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下面是JMM针对编译器制定的volatile重排序规则表：</p><table><tr><td><p>是否能重排序</p></td><td colspan="3"><p>第二个操作</p></td></tr><tr><td><p>第一个操作</p></td><td><p>普通读/写</p></td><td><p>volatile读</p></td><td><p>volatile写</p></td></tr><tr><td><p>普通读/写</p></td><td></td><td></td><td><p>NO</p></td></tr><tr><td><p>volatile读</p></td><td><p>NO</p></td><td><p>NO</p></td><td><p>NO</p></td></tr><tr><td><p>volatile写</p></td><td></td><td><p>NO</p></td><td><p>NO</p></td></tr></table><p>举例来说，第三行最后一个单元格的意思是：在程序顺序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p><p>从上表我们可以看出：</p><ul><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li></ul><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p><p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：</p><p>上图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。</p><p>这里比较有意思的是volatile写后面的StoreLoad屏障。这个屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面，是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确实现volatile的内存语义，JMM在这里采取了保守策略：在每个volatile写的后面或在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里我们可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p><p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图：</p><p>上图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p><p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面我们通过具体的示例代码来说明：</p><p>class VolatileBarrierExample {</p><p>    int a;</p><p>    volatile int v1 = 1;</p><p>    volatile int v2 = 2;</p><p>    void readAndWrite() {</p><p>        int i = v1;           //第一个volatile读</p><p>        int j = v2;           // 第二个volatile读</p><p>        a = i + j;            //普通写</p><p>        v1 = i + 1;          // 第一个volatile写</p><p>        v2 = j * 2;          //第二个 volatile写</p><p>    }</p><p>    …                    //其他方法</p><p>}</p><p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化：</p><p>注意，最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。此时编译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器常常会在这里插入一个StoreLoad屏障。</p><p>上面的优化是针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以x86处理器为例，上图中除最后的StoreLoad屏障外，其它的屏障都会被省略。</p><p>前面保守策略下的volatile读和写，在 x86处理器平台可以优化成：</p><p>前文提到过，x86处理器仅会对写-读操作做重排序。X86不会对读-读，读-写和写-写操作做重排序，因此在x86处理器中会省略掉这三种操作类型对应的内存屏障。在x86中，JMM仅需在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在x86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。</p><h2><a id="t25"></a>JSR-133为什么要增强volatile的内存语义</h2><p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量之间重排序。在旧的内存模型中，VolatileExample示例程序可能被重排序成下列时序来执行：</p><p>在旧的内存模型中，当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</p><p>因此在旧的内存模型中 ，volatile的写-读没有监视器的释放-获所具有的内存语义。为了提供一种比监视器锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和监视器的释放-获取一样，具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p><p>由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。如果读者想在程序中用volatile代替监视器锁，请一定谨慎。</p><a id="t26"></a><h1><a href="http://www.infoq.com/cn/articles/java-memory-model-5&quot; \t &quot;_blank">深入理解Java内存模型（五）——锁</a></h1><h2><a id="t27"></a>锁的释放-获取建立的happens before 关系</h2><p>锁是java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p><p>下面是锁释放-获取的示例代码：</p><p>class MonitorExample {</p><p>    int a = 0;</p><p>    public synchronized void writer() {  //1</p><p>        a++;                             //2</p><p>    }                                    //3</p><p>    public synchronized void reader() {  //4</p><p>        int i = a;                       //5</p><p>        ……</p><p>    }                                    //6</p><p>}</p><p>假设线程A执行writer()方法，随后线程B执行reader()方法。根据happens before规则，这个过程包含的happens before 关系可以分为两类：</p><ol><li>根据程序次序规则，1 happens before 2, 2 happens before 3; 4 happens before 5, 5 happens before 6。</li><li>根据监视器锁规则，3 happens before 4。</li><li>根据happens before 的传递性，2 happens before 5。</li></ol><p>上述happens before 关系的图形化表现形式如下：</p><p>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p><p>上图表示在线程A释放了锁之后，随后线程B获取同一个锁。在上图中，2 happens before 5。因此，线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立刻变得对B线程可见。</p><h2><a id="t28"></a>锁释放和获取的内存语义</h2><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的MonitorExample程序为例，A线程释放锁后，共享数据的状态示意图如下：</p><p>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。下面是锁获取的状态示意图：</p><p>对比锁释放-获取的内存语义与volatile写-读的内存语义，可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</p><p>下面对锁释放和锁获取的内存语义做个总结：</p><ul><li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li><li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li><li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><h2><a id="t29"></a>锁内存语义的实现</h2><p>本文将借助ReentrantLock的源代码，来分析锁内存语义的具体实现机制。</p><p>请看下面的示例代码：</p><p>class ReentrantLockExample {</p><p>int a = 0;</p><p>ReentrantLock lock = new ReentrantLock();</p><p>public void writer() {</p><p>    lock.lock();         //获取锁</p><p>    try {</p><p>        a++;</p><p>    } finally {</p><p>        lock.unlock();  //释放锁</p><p>    }</p><p>}</p><p>public void reader () {</p><p>    lock.lock();        //获取锁</p><p>    try {</p><p>        int i = a;</p><p>        ……</p><p>    } finally {</p><p>        lock.unlock();  //释放锁</p><p>    }</p><p>}</p><p>}</p><p>在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。</p><p>ReentrantLock的实现依赖于java同步器框架AbstractQueuedSynchronizer（本文简称之为AQS）。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，马上我们会看到，这个volatile变量是ReentrantLock内存语义实现的关键。 下面是ReentrantLock的类图（仅画出与本文相关的部分）：</p><p>ReentrantLock分为公平锁和非公平锁，我们首先分析公平锁。</p><p>使用公平锁时，加锁方法lock()的方法调用轨迹如下：</p><ol><li>ReentrantLock : lock()</li><li>FairSync : lock()</li><li>AbstractQueuedSynchronizer : acquire(int arg)</li><li>ReentrantLock : tryAcquire(int acquires)</li></ol><p>在第4步真正开始加锁，下面是该方法的源代码：</p><p>protected final boolean tryAcquire(int acquires) {</p><p>    final Thread current = Thread.currentThread();</p><p>    int c = getState();   //获取锁的开始，首先读volatile变量state</p><p>    if (c == 0) {</p><p>        if (isFirst(current) &amp;&amp;</p><p>            compareAndSetState(0, acquires)) {</p><p>            setExclusiveOwnerThread(current);</p><p>            return true;</p><p>        }</p><p>    }</p><p>    else if (current == getExclusiveOwnerThread()) {</p><p>        int nextc = c + acquires;</p><p>        if (nextc &lt; 0)  </p><p>            throw new Error("Maximum lock count exceeded");</p><p>        setState(nextc);</p><p>        return true;</p><p>    }</p><p>    return false;</p><p>}</p><p>从上面源代码中我们可以看出，加锁方法首先读volatile变量state。</p><p>在使用公平锁时，解锁方法unlock()的方法调用轨迹如下：</p><ol><li>ReentrantLock : unlock()</li><li>AbstractQueuedSynchronizer : release(int arg)</li><li>Sync : tryRelease(int releases)</li></ol><p>在第3步真正开始释放锁，下面是该方法的源代码：</p><p>protected final boolean tryRelease(int releases) {</p><p>    int c = getState() - releases;</p><p>    if (Thread.currentThread() != getExclusiveOwnerThread())</p><p>        throw new IllegalMonitorStateException();</p><p>    boolean free = false;</p><p>    if (c == 0) {</p><p>        free = true;</p><p>        setExclusiveOwnerThread(null);</p><p>    }</p><p>    setState(c);           //释放锁的最后，写volatile变量state</p><p>    return free;</p><p>}</p><p>从上面的源代码我们可以看出，在释放锁的最后写volatile变量state。</p><p>公平锁在释放锁的最后写volatile变量state；在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变的对获取锁的线程可见。</p><p>现在我们分析非公平锁的内存语义的实现。</p><p>非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。</p><p>使用公平锁时，加锁方法lock()的方法调用轨迹如下：</p><ol><li>ReentrantLock : lock()</li><li>NonfairSync : lock()</li><li>AbstractQueuedSynchronizer : compareAndSetState(int expect, int update)</li></ol><p>在第3步真正开始加锁，下面是该方法的源代码：</p><p>protected final boolean compareAndSetState(int expect, int update) {</p><p>    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</p><p>}</p><p>该方法以原子操作的方式更新state变量，本文把java的compareAndSet()方法调用简称为CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有 volatile 读和写的内存语义。</p><p>这里我们分别从编译器和处理器的角度来分析,CAS如何同时具有volatile读和volatile写的内存语义。</p><p>前文我们提到过，编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p><p>下面我们来分析在常见的intel x86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的。</p><p>下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码：</p><p>public final native boolean compareAndSwapInt(Object o, long offset,</p><p>                                              int expected,</p><p>                                              int x);</p><p>可以看到这是个本地方法调用。这个本地方法在openjdk中依次调用的c++代码为：unsafe.cpp，atomic.cpp和atomicwindowsx86.inline.hpp。这个本地方法的最终实现在openjdk的如下位置：openjdk-7-fcs-src-b147-27jun2011\openjdk\hotspot\src\oscpu\windowsx86\vm\ atomicwindowsx86.inline.hpp（对应于windows操作系统，X86处理器）。下面是对应于intel x86处理器的源代码的片段：</p><p>// Adding a lock prefix to an instruction on MP machine</p><p>// VC++ doesn't like the lock prefix to be on a single line</p><p>// so we can't insert a label after the lock prefix.</p><p>// By emitting a lock prefix, we can define a label after it.</p><p>#define LOCK_IF_MP(mp) __asm cmp mp, 0  \</p><p>                       __asm je L0      \</p><p>                       __asm _emit 0xF0 \</p><p>                       __asm L0:</p><p>inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {</p><p>  // alternative for InterlockedCompareExchange</p><p>  int mp = os::is_MP();</p><p>  __asm {</p><p>    mov edx, dest</p><p>    mov ecx, exchange_value</p><p>    mov eax, compare_value</p><p>    LOCK_IF_MP(mp)</p><p>    cmpxchg dword ptr [edx], ecx</p><p>  }</p><p>}</p><p>如上面源代码所示，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。</p><p>intel的手册对lock前缀的说明如下：</p><ol><li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li><li>禁止该指令与之前和之后的读和写指令重排序。</li><li>把写缓冲区中的所有数据刷新到内存中。</li></ol><p>上面的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。</p><p>经过上面的这些分析，现在我们终于能明白为什么JDK文档说CAS同时具有volatile读和volatile写的内存语义了。</p><p>现在对公平锁和非公平锁的内存语义做个总结：</p><ul><li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li><li>公平锁获取时，首先会去读这个volatile变量。</li><li>非公平锁获取时，首先会用CAS更新这个volatile变量,这个操作同时具有volatile读和volatile写的内存语义。</li></ul><p>从本文对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式：</p><ol><li>利用volatile变量的写-读所具有的内存语义。</li><li>利用CAS所附带的volatile读和volatile写的内存语义。</li></ol><h2><a id="t30"></a>concurrent包的实现</h2><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p><ol><li>A线程写volatile变量，随后B线程读这个volatile变量。</li><li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li></ol><p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p><ol><li>首先，声明共享变量为volatile；</li><li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li><li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li></ol><p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：</p><h2><a id="t31"></a></h2><a id="t32"></a><h1><a href="http://www.infoq.com/cn/articles/java-memory-model-6&quot; \t &quot;_blank">深入理解Java内存模型（六）——final</a></h1><p>面介绍的锁和volatile相比较，对final域的读和写更像是普通的变量访问。对于final域，编译器和处理器要遵守两个重排序规则：</p><ol><li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li></ol><p>下面，我们通过一些示例性的代码来分别说明这两个规则：</p><p>public class FinalExample {</p><p>    int i;                            //普通变量</p><p>    final int j;                      //final变量</p><p>    static FinalExample obj;</p><p>    public void FinalExample () {     //构造函数</p><p>        i = 1;                        //写普通域</p><p>        j = 2;                        //写final域</p><p>    }</p><p>    public static void writer () {    //写线程A执行</p><p>        obj = new FinalExample ();</p><p>    }</p><p>    public static void reader () {       //读线程B执行</p><p>        FinalExample object = obj;       //读对象引用</p><p>        int a = object.i;                //读普通域</p><p>        int b = object.j;                //读final域</p><p>    }</p><p>}</p><p>这里假设一个线程A执行writer ()方法，随后另一个线程B执行reader ()方法。下面我们通过这两个线程的交互来说明这两个规则。</p><h2><a id="t33"></a>写final域的重排序规则</h2><p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p><ul><li>JMM禁止编译器把final域的写重排序到构造函数之外。</li><li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li></ul><p>现在让我们分析writer ()方法。writer ()方法只包含一行代码：finalExample = new FinalExample ()。这行代码包含两个步骤：</p><ol><li>构造一个FinalExample类型的对象；</li><li>把这个对象的引用赋值给引用变量obj。</li></ol><p>假设线程B读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：</p><p>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程B错误的读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确的读取了final变量初始化之后的值。</p><p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程B“看到”对象引用obj时，很可能obj对象还没有构造完成（对普通域i的写操作被重排序到构造函数外，此时初始值2还没有写入普通域i）。</p><h2><a id="t34"></a>读final域的重排序规则</h2><p>读final域的重排序规则如下：</p><ul><li>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。</li></ul><p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器。</p><p>reader()方法包含三个操作：</p><ol><li>初次读引用变量obj;</li><li>初次读引用变量obj指向对象的普通域j。</li><li>初次读引用变量obj指向对象的final域i。</li></ol><p>现在我们假设写线程A没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：</p><p>在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写入，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。</p><p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。</p><h2><a id="t35"></a>如果final域是引用类型</h2><p>上面我们看到的final域是基础数据类型，下面让我们看看如果final域是引用类型，将会有什么效果？</p><p>请看下列示例代码：</p><p>public class FinalReferenceExample {</p><p>final int[] intArray;                     //final是引用类型</p><p>static FinalReferenceExample obj;</p><p>public FinalReferenceExample () {        //构造函数</p><p>    intArray = new int[1];              //1</p><p>    intArray[0] = 1;                   //2</p><p>}</p><p>public static void writerOne () {          //写线程A执行</p><p>    obj = new FinalReferenceExample ();  //3</p><p>}</p><p>public static void writerTwo () {          //写线程B执行</p><p>    obj.intArray[0] = 2;                 //4</p><p>}</p><p>public static void reader () {              //读线程C执行</p><p>    if (obj != null) {                    //5</p><p>        int temp1 = obj.intArray[0];       //6</p><p>    }</p><p>}</p><p>}</p><p>这里final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：</p><ol><li>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li></ol><p>对上面的示例程序，我们假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader ()方法。下面是一种可能的线程执行时序：</p><p>在上图中，1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p><p>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看的到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p><p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p><h2><a id="t36"></a>为什么final引用不能从构造函数内“逸出”</h2><p>前面我们提到过，写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，让我们来看下面示例代码：</p><p>public class FinalReferenceEscapeExample {</p><p>final int i;</p><p>static FinalReferenceEscapeExample obj;</p><p>public FinalReferenceEscapeExample () {</p><p>    i = 1;                              //1写final域</p><p>    obj = this;                          //2 this引用在此“逸出”</p><p>}</p><p>public static void writer() {</p><p>    new FinalReferenceEscapeExample ();</p><p>}</p><p>public static void reader {</p><p>    if (obj != null) {                     //3</p><p>        int temp = obj.i;                 //4</p><p>    }</p><p>}</p><p>}</p><p>假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且即使在程序中操作2排在操作1后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。实际的执行时序可能如下图所示：</p><p>从上图我们可以看出：在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p><h2><a id="t37"></a>final语义在处理器中的实现</h2><p>现在我们以x86处理器为例，说明final语义在处理器中的具体实现。</p><p>上面我们提到，写final域的重排序规则会要求译编器在final域的写之后，构造函数return之前，插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。</p><p>由于x86处理器不会对写-写操作做重排序，所以在x86处理器中，写final域需要的StoreStore障屏会被省略掉。同样，由于x86处理器不会对存在间接依赖关系的操作做重排序，所以在x86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说在x86处理器中，final域的读/写不会插入任何内存屏障！</p><h2><a id="t38"></a>JSR-133为什么要增强final的语义</h2><p>在旧的Java内存模型中 ，最严重的一个缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整形final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为了1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变（参考文献2中有一个具体的例子，感兴趣的读者可以自行参考，这里就不赘述了）。</p><p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用），就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p><p><br /></p><a id="t39"></a><h1><a href="http://www.infoq.com/cn/articles/java-memory-model-7&quot; \t &quot;_blank">深入理解Java内存模型（七）——总结</a></h1><h2><a id="t40"></a>处理器内存模型</h2><p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。</p><p>根据对不同类型读/写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型：</p><ol><li>放松程序中写-读操作的顺序，由此产生了total store ordering内存模型（简称为TSO）。</li><li>在前面1的基础上，继续放松程序中写-写操作的顺序，由此产生了partial store order 内存模型（简称为PSO）。</li><li>在前面1和2的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了relaxed memory order内存模型（简称为RMO）和PowerPC内存模型。</li></ol><p>注意，这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。</p><p>下面的表格展示了常见处理器内存模型的细节特征：</p><table><tr><td><p>内存模型名称</p></td><td><p>对应的处理器</p></td><td><p>Store-Load 重排序</p></td><td><p>Store-Store重排序</p></td><td><p>Load-Load 和Load-Store重排序</p></td><td><p>可以更早读取到其它处理器的写</p></td><td><p>可以更早读取到当前处理器的写</p></td></tr><tr><td><p>TSO</p></td><td><p>sparc-TSO</p><p>X64</p></td><td><p>Y</p></td><td></td><td></td><td></td><td><p>Y</p></td></tr><tr><td><p>PSO</p></td><td><p>sparc-PSO</p></td><td><p>Y</p></td><td><p>Y</p></td><td></td><td></td><td><p>Y</p></td></tr><tr><td><p>RMO</p></td><td><p>ia64</p></td><td><p>Y</p></td><td><p>Y</p></td><td><p>Y</p></td><td></td><td><p>Y</p></td></tr><tr><td><p>PowerPC</p></td><td><p>PowerPC</p></td><td><p>Y</p></td><td><p>Y</p></td><td><p>Y</p></td><td><p>Y</p></td><td><p>Y</p></td></tr></table><p>在这个表格中，我们可以看到所有处理器内存模型都允许写-读重排序，原因在第一章以说明过：它们都使用了写缓存区，写缓存区可能导致写-读操作重排序。同时，我们可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。</p><p>上面表格中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。</p><p>由于常见的处理器内存模型比JMM要弱，java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了JMM在不同处理器内存模型中需要插入的内存屏障的示意图：</p><p>如上图所示，JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为java程序员呈现了一个一致的内存模型。</p><h2><a id="t41"></a>JMM，处理器内存模型与顺序一致性内存模型之间的关系</h2><p>JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p><p>从上图我们可以看出：常见的4种处理器内存模型比常用的3中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。</p><h2><a id="t42"></a>JMM的设计</h2><p>从JMM设计者的角度来说，在设计JMM时，需要考虑两个关键因素：</p><ul><li>程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。</li><li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li></ul><p>由于这两个因素互相矛盾，所以JSR-133专家组在设计JMM时的核心目标就是找到一个好的平衡点：一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。下面让我们看看JSR-133是如何实现这一目标的。</p><p>为了具体说明，请看前面提到过的计算圆面积的示例代码：</p><p>double pi  = 3.14;    //A</p><p>double r   = 1.0;     //B</p><p>double area = pi * r * r; //C</p><p>上面计算圆的面积的示例代码存在三个happens- before关系：</p><ol><li>A happens- before B；</li><li>B happens- before C；</li><li>A happens- before C；</li></ol><p>由于A happens- before B，happens- before的定义会要求：A操作执行的结果要对B可见，且A操作的执行顺序排在B操作之前。 但是从程序语义的角度来说，对A和B做重排序即不会改变程序的执行结果，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这3个happens- before关系中，虽然2和3是必需要的，但1是不必要的。因此，JMM把happens- before要求禁止的重排序分为了下面两类：</p><ul><li>会改变程序执行结果的重排序。</li><li>不会改变程序执行结果的重排序。</li></ul><p>JMM对这两种不同性质的重排序，采取了不同的策略：</p><ul><li>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</li><li>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不作要求（JMM允许这种重排序）。</li></ul><p>下面是JMM的设计示意图：</p><p>从上图可以看出两点：</p><ul><li>JMM向程序员提供的happens- before规则能满足程序员的需求。JMM的happens- before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A happens- before B）。</li><li>JMM对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个volatile变量仅仅只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li></ul><h2><a id="t43"></a>JMM的内存可见性保证</h2><p>Java程序的内存可见性保证按程序类型可以分为下列三类：</p><ol><li>单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li><li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li><li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</li></ol><p>下图展示了这三类程序在JMM中与在顺序一致性内存模型中的执行结果的异同：</p><p>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p><h2><a id="t44"></a>JSR-133对旧内存模型的修补</h2><p>JSR-133对JDK5之前的旧内存模型的修补主要有两个：</p><ul><li>增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</li><li>增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。现在，final具有了初始化安全性。</li></ul><h1>转载于：<a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk">http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk</a></h1
</body>
</html>
